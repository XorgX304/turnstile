#!/usr/bin/env node
'use strict';

const FS = require('fs');
const Path = require('path');
const URL = require('url');

global.Config = require('nconf');

Config.argv({
  config: {
    alias: 'c',
    describe: 'Path to local turnstile configuration'
  },
  method: {
    alias: 'X',
    describe: 'HTTP request method',
    default: 'GET'
  },
  payload: {
    alias: 'd',
    describe: 'HTTP request payload',
    default: ''
  },
  digest: {
    describe: 'Digest signing scheme',
    default: 'SHA256'
  },
  header: {
    alias: 'H',
    array: true,
    describe: 'HTTP request headers'
  },
  output: {
    alias: 'o',
    describe: 'Write output to a file',
    default: false
  },

  identity: {
    alias: 'u',
    demand: true,
    describe: 'Identity key for the request'
  },
  secret: {
    alias: 'p',
    demand: true,
    describe: 'Secret key for the request'
  }
});

Config.defaults({
  log: {
    json: false,
    timestamp: false,
    colorize: true
  }
});

require('../lib/log');
const turnt = require('../test/resource/turnt');

/**
 * Load request data from STDIN, a file, or from the argument value
 * @param  {String} payload The value of the `-d/--payload` flag. A `-` indicates
 *                          that data should be read from STDIN, while a leading `@`
 *                          indicates that the rest of the value is the path to a
 *                          file that should be read.
 * @return {Promise}
 */
const read = (payload) => {
  return new Promise((resolve, reject) => {
    if (typeof payload !== 'string' && !(payload instanceof Buffer)) {
      return resolve(false);
    }

    switch (payload[0]) {
    case '-': // Read from STDIN
      const data = [];

      process.stdin.on('data', (chunk) => data.push(chunk));
      process.stdin.on('end', () => resolve(Buffer.concat(data)));
      break;

    case '@': // Read from a file
      FS.readFile(Path.resolve(__dirname, payload.slice(1)), (err, data) => {
        if (err) {
          return reject(err);
        }

        resolve(data);
      });
      break;

    default: // Convert argument value to a buffer
      resolve(Buffer.from(payload, 'utf8'));
    }
  });
};

const date = new Date();
const url = Config.get('_')[0];
const params = URL.parse(url);

params.method = Config.get('method');
params.headers = {
  date: date.toUTCString(),
  host: params.host,
  'user-agent': `node-${process.version}/turnstile-tester`
};

// Round date to the nearest seconds for signing
params.date = new Date(date);
params.date.setMilliseconds(0);

params.identity = Config.get('identity');

turnt.request(params).then((res) => {
  const output = Config.get('output');
  const body = res.body;

  if (!output) {
    process.stdout.write(body);

    return;
  }

  if (body.length > 0) {
    FS.writeFile(output, body, (err) => {
      if (err) {
        throw err;
      }

      Log.info(`Wrote ${res.body.length} bytes to ${output}`);
    });
  }
}).catch((err) => {
  Log.error(err);
  process.stdout.write(err.error);
});
